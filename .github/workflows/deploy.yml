name: Deploy to AWS ECS (Simple)

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
    types: [closed]

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: breiq-backend
  ECS_SERVICE: breiq-production-backend
  ECS_CLUSTER: breiq-production-cluster

jobs:
  deploy:
    name: Deploy Laravel API
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)

    steps:
      - name: üöÄ Notify Deployment Start
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          message: |
            üöÄ **AWS ECS Deployment Started**

            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: `${{ github.sha }}`
            Author: ${{ github.actor }}

            ‚è≥ Starting AWS deployment process...

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.SUBMODULE_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create .env.production from secrets
        run: |
          cd breiq-backend
          cat > .env.production << 'EOF'
          # Application
          APP_NAME="Breiq API"
          APP_ENV=production
          APP_KEY="${{ secrets.APP_KEY }}"
          APP_DEBUG=false
          APP_TIMEZONE=UTC
          APP_URL="${{ secrets.APP_URL }}"

          # Database - AWS RDS PostgreSQL
          DB_CONNECTION=pgsql
          DB_HOST="${{ secrets.DB_HOST }}"
          DB_PORT=5432
          DB_DATABASE=breiq_production
          DB_USERNAME=breiq_admin
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"

          # Cache & Sessions - AWS ElastiCache Redis
          CACHE_STORE=redis
          SESSION_DRIVER=redis
          REDIS_CLIENT=phpredis
          REDIS_HOST="${{ secrets.REDIS_HOST }}"
          REDIS_PASSWORD=
          REDIS_PORT=6379
          REDIS_PREFIX=breiq_production_cache_

          # Queue - AWS SQS
          QUEUE_CONNECTION=sqs
          SQS_PREFIX=https://queue.amazonaws.com/021891607194
          SQS_QUEUE=breiq-production-queue
          SQS_SUFFIX=

          # File Storage - AWS S3
          FILESYSTEM_DISK=s3
          AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}"
          AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          AWS_DEFAULT_REGION=us-east-1
          AWS_BUCKET=breiq-production-videos
          AWS_URL=
          AWS_ENDPOINT=
          AWS_USE_PATH_STYLE_ENDPOINT=false

          # Logging
          LOG_CHANNEL=errorlog
          LOG_STACK=single
          LOG_LEVEL=error

          # Sentry Error Tracking
          SENTRY_LARAVEL_DSN="${{ secrets.SENTRY_LARAVEL_DSN }}"
          SENTRY_SEND_DEFAULT_PII=true
          SENTRY_TRACES_SAMPLE_RATE=1.0

          # Google OAuth
          GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}"
          GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}"
          GOOGLE_REDIRECT_URI="${APP_URL}/auth/google/callback"

          # Firebase Cloud Messaging
          FCM_SERVER_KEY="${{ secrets.FCM_SERVER_KEY }}"
          FCM_SENDER_ID="${{ secrets.FCM_SENDER_ID }}"
          FCM_PROJECT_ID="${{ secrets.FCM_PROJECT_ID }}"

          # Video Processing Configuration
          MAX_VIDEO_SIZE_MB=100
          MAX_VIDEO_DURATION_SECONDS=300
          SUPPORTED_VIDEO_FORMATS=mp4,mov,avi,wmv

          # Production Security Settings
          SANCTUM_STATEFUL_DOMAINS=breiq.online,api.breiq.online
          SESSION_DOMAIN=.breiq.online
          CORS_ALLOWED_ORIGINS="https://breiq.online,app://breiq"

          # Telescope Configuration for Production Debugging
          TELESCOPE_ENABLED=true
          TELESCOPE_PATH=telescope
          TELESCOPE_BASIC_AUTH_USER="${{ secrets.TELESCOPE_BASIC_AUTH_USER }}"
          TELESCOPE_BASIC_AUTH_PASSWORD="${{ secrets.TELESCOPE_BASIC_AUTH_PASSWORD }}"
          EOF

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd breiq-backend

          # Create simple Dockerfile
          cat > Dockerfile << 'EOF'
          FROM webdevops/php-nginx:8.2-alpine

          # Install curl for health checks
          RUN apk add --no-cache curl

          # Set document root for Laravel
          ENV WEB_DOCUMENT_ROOT=/app/public

          # Set working directory
          WORKDIR /app

          # Copy application files
          COPY --chown=application:application . /app

          # Copy production environment file to .env (Laravel's default)
          RUN cp /app/.env.production /app/.env

          # Install composer dependencies
          RUN composer install --no-dev --optimize-autoloader --no-interaction

          # Create Laravel startup script that works with webdevops image
          RUN echo '#!/bin/bash' > /app/laravel-init.sh && \
              echo 'set -e' >> /app/laravel-init.sh && \
              echo 'echo "[INIT] Initializing Laravel application..."' >> /app/laravel-init.sh && \
              echo 'export TELESCOPE_ENABLED=true' >> /app/laravel-init.sh && \
              echo 'php artisan config:cache --no-interaction || echo "[ERROR] Config cache failed"' >> /app/laravel-init.sh && \
              echo 'php artisan route:cache --no-interaction || echo "[ERROR] Route cache failed"' >> /app/laravel-init.sh && \
              echo 'echo "[INIT] Laravel initialization complete!"' >> /app/laravel-init.sh && \
              chmod +x /app/laravel-init.sh

          # Run Laravel optimizations during build with Telescope enabled
          RUN TELESCOPE_ENABLED=true /app/laravel-init.sh

          # Add health check for the container
          HEALTHCHECK --interval=30s --timeout=10s --start-period=90s --retries=5 \
            CMD curl -f http://localhost/api/health || exit 1

          EXPOSE 80

          # Use webdevops default entrypoint (supervisord with nginx + php-fpm)
          # This should resolve the supervisor config file not found error
          CMD ["/entrypoint", "supervisord"]
          EOF

          # Build and push
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Update ECS service
        run: |
          echo "üîÑ Updating ECS service with new image..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          echo "‚è≥ Waiting for service to stabilize (timeout: 10 minutes)..."

          # Use timeout to prevent hanging indefinitely
          if timeout 600 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}; then
            echo "‚úÖ Service stabilized successfully"
          else
            echo "‚ö†Ô∏è Service stabilization timed out, checking service status..."

            # Get service status even if stabilization timed out
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].deployments[0].status' \
              --output text)

            RUNNING_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].runningCount' \
              --output text)

            DESIRED_COUNT=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].desiredCount' \
              --output text)

            echo "üìä Service Status: $SERVICE_STATUS"
            echo "üìä Running Tasks: $RUNNING_COUNT/$DESIRED_COUNT"

            if [ "$RUNNING_COUNT" -eq "$DESIRED_COUNT" ] && [ "$RUNNING_COUNT" -gt 0 ]; then
              echo "‚úÖ Service appears healthy despite stabilization timeout"
            else
              echo "‚ùå Service may not be healthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running"

              # Get recent service events for debugging
              echo "üìã Recent service events:"
              aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].events[:5].[message]' \
                --output table

              exit 1
            fi
          fi

      - name: Get deployment info
        id: deployment-info
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names breiq-production-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text \
            --region ${{ env.AWS_REGION }})

          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "üöÄ Deployment completed successfully!"
          echo "API Endpoint: http://$ALB_DNS/api/health"

      - name: Clear Laravel caches post-deployment
        run: |
          echo "üóëÔ∏è Clearing Laravel caches in running containers..."

          # Get running task ARNs
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --desired-status RUNNING \
            --region ${{ env.AWS_REGION }} \
            --query 'taskArns' \
            --output text)

          if [ -z "$TASK_ARNS" ]; then
            echo "‚ùå No running tasks found"
            exit 1
          fi

          # Clear caches on first running task
          FIRST_TASK=$(echo $TASK_ARNS | awk '{print $1}')
          echo "üìã Clearing caches on task: $FIRST_TASK"

          # Execute cache clearing commands
          echo "üóëÔ∏è Clearing configuration cache..."
          aws ecs execute-command \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task "$FIRST_TASK" \
            --container breiq-backend \
            --command "php /app/artisan config:clear" \
            --interactive \
            --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è Config cache clear failed"

          echo "üóëÔ∏è Clearing route cache..."
          aws ecs execute-command \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task "$FIRST_TASK" \
            --container breiq-backend \
            --command "php /app/artisan route:clear" \
            --interactive \
            --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è Route cache clear failed"

          echo "üóëÔ∏è Clearing view cache..."
          aws ecs execute-command \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task "$FIRST_TASK" \
            --container breiq-backend \
            --command "php /app/artisan view:clear" \
            --interactive \
            --region ${{ env.AWS_REGION }} || echo "‚ö†Ô∏è View cache clear failed"

          echo "‚úÖ Cache clearing completed"

      - name: ‚úÖ Notify Deployment Success
        if: success()
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          message: |
            ‚úÖ **AWS ECS Deployment Successful!**

            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: `${{ github.sha }}`
            Author: ${{ github.actor }}

            üéâ Laravel API deployed successfully to AWS!

            üåê **Live Endpoints:**
            ‚Ä¢ API Health: http://${{ steps.deployment-info.outputs.alb_dns }}/api/health
            ‚Ä¢ API Base: http://${{ steps.deployment-info.outputs.alb_dns }}/api/
            ‚Ä¢ Telescope: http://${{ steps.deployment-info.outputs.alb_dns }}/telescope (auth required)

            üê≥ **Container Details:**
            ‚Ä¢ Image: ${{ steps.build-image.outputs.image }}
            ‚Ä¢ Cluster: ${{ env.ECS_CLUSTER }}
            ‚Ä¢ Service: ${{ env.ECS_SERVICE }}

      - name: ‚ùå Notify Deployment Failure
        if: failure()
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          message: |
            ‚ùå **AWS ECS Deployment Failed!**

            Repository: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: `${{ github.sha }}`
            Author: ${{ github.actor }}

            üí• Deployment failed during AWS execution

            üîó Check the GitHub Actions logs for details:
            https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
