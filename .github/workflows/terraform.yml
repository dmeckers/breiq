name: 'Terraform Infrastructure Deployment'

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'terraform/**'
  pull_request:
    branches:
      - main
    paths:
      - 'terraform/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  TF_VERSION: '1.6.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform-validate:
    name: 'Terraform Validate'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Format Check
        id: fmt
        run: terraform fmt -check -recursive
        working-directory: ./terraform
        continue-on-error: true
        
      - name: Terraform Init
        id: init
        run: terraform init -backend=false
        working-directory: ./terraform
        
      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color
        working-directory: ./terraform
        
      - name: Comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          FMT: ${{ steps.fmt.outcome }}
          INIT: ${{ steps.init.outcome }}
          VALIDATE: ${{ steps.validate.outcome }}
        with:
          script: |
            const output = `#### Terraform Format and Validation 📋
            - **Format Check**: \`${{ env.FMT }}\`
            - **Initialization**: \`${{ env.INIT }}\`
            - **Validation**: \`${{ env.VALIDATE }}\`
            
            <details><summary>Show Validation Output</summary>
            
            \`\`\`\n
            ${{ steps.validate.outputs.stdout }}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    
    strategy:
      matrix:
        environment: [staging, production]
        
    environment: ${{ matrix.environment }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=breiq-${{ matrix.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"
        working-directory: ./terraform
        
      - name: Create Terraform Variables File
        run: |
          cat > terraform.tfvars << EOF
          aws_region = "${{ env.AWS_REGION }}"
          environment = "${{ matrix.environment }}"
          project_name = "breiq"
          domain_name = "${{ secrets.DOMAIN_NAME }}"
          enable_multi_region = ${{ matrix.environment == 'production' }}
          
          # Video bucket CORS origins
          video_bucket_cors_origins = [
            "https://${{ secrets.DOMAIN_NAME }}",
            "https://www.${{ secrets.DOMAIN_NAME }}",
            "https://app.${{ secrets.DOMAIN_NAME }}",
            "https://admin.${{ secrets.DOMAIN_NAME }}"
          ]
          
          # Performance settings for production
          ${{ matrix.environment == 'production' && 'rds_instance_class = "db.r6g.xlarge"' || 'rds_instance_class = "db.r6g.large"' }}
          ${{ matrix.environment == 'production' && 'redis_node_type = "cache.r6g.xlarge"' || 'redis_node_type = "cache.r6g.large"' }}
          ${{ matrix.environment == 'production' && 'redis_num_nodes = 3' || 'redis_num_nodes = 2' }}
          
          # Monitoring
          enable_enhanced_monitoring = ${{ matrix.environment == 'production' }}
          alert_email = "${{ secrets.ALERT_EMAIL }}"
          EOF
        working-directory: ./terraform
        
      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -out=tfplan
        working-directory: ./terraform
        continue-on-error: true
        
      - name: Save Plan Output
        run: terraform show -no-color tfplan > plan_output.txt
        working-directory: ./terraform
        
      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('./terraform/plan_output.txt', 'utf8');
            const output = `## Terraform Plan - ${{ matrix.environment }} 📋
            
            <details><summary>Show Plan</summary>
            
            \`\`\`hcl
            ${plan}
            \`\`\`
            
            </details>
            
            *Environment: ${{ matrix.environment }}*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  terraform-apply-staging:
    name: 'Deploy to Staging'
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    
    environment: staging
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=breiq-staging/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"
        working-directory: ./terraform
        
      - name: Create Terraform Variables File
        run: |
          cat > terraform.tfvars << EOF
          aws_region = "${{ env.AWS_REGION }}"
          environment = "staging"
          project_name = "breiq"
          domain_name = "${{ secrets.DOMAIN_NAME }}"
          enable_multi_region = false
          
          video_bucket_cors_origins = [
            "https://staging.${{ secrets.DOMAIN_NAME }}",
            "https://app-staging.${{ secrets.DOMAIN_NAME }}"
          ]
          
          rds_instance_class = "db.r6g.large"
          redis_node_type = "cache.r6g.large"
          redis_num_nodes = 2
          
          enable_enhanced_monitoring = false
          alert_email = "${{ secrets.ALERT_EMAIL }}"
          EOF
        working-directory: ./terraform
        
      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ./terraform

  terraform-apply-production:
    name: 'Deploy to Production'
    runs-on: ubuntu-latest
    needs: terraform-validate
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    environment: production
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          
      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=breiq-production/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE }}"
        working-directory: ./terraform
        
      - name: Create Terraform Variables File
        run: |
          cat > terraform.tfvars << EOF
          aws_region = "${{ env.AWS_REGION }}"
          environment = "production"
          project_name = "breiq"
          domain_name = "${{ secrets.DOMAIN_NAME }}"
          enable_multi_region = true
          
          video_bucket_cors_origins = [
            "https://${{ secrets.DOMAIN_NAME }}",
            "https://www.${{ secrets.DOMAIN_NAME }}",
            "https://app.${{ secrets.DOMAIN_NAME }}",
            "https://admin.${{ secrets.DOMAIN_NAME }}"
          ]
          
          # Production-optimized settings
          rds_instance_class = "db.r6g.xlarge"
          redis_node_type = "cache.r6g.xlarge"
          redis_num_nodes = 3
          rds_backup_retention = 30
          enable_rds_multi_az = true
          
          # Enhanced monitoring for production
          enable_enhanced_monitoring = true
          alert_email = "${{ secrets.ALERT_EMAIL }}"
          
          # SSL certificate ARN (if using custom domain)
          # ssl_certificate_arn = "${{ secrets.SSL_CERTIFICATE_ARN }}"
          EOF
        working-directory: ./terraform
        
      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ./terraform
        
      - name: Post-deployment Health Check
        run: |
          echo "Waiting for infrastructure to be ready..."
          sleep 120
          
          # Get ALB DNS name from Terraform output
          ALB_DNS=$(terraform output -raw load_balancer_dns)
          echo "Testing health endpoint: http://$ALB_DNS/api/health"
          
          # Simple health check
          for i in {1..10}; do
            if curl -f "http://$ALB_DNS/api/health" > /dev/null 2>&1; then
              echo "✅ Health check passed!"
              break
            else
              echo "⏳ Attempt $i/10 failed, retrying in 30s..."
              sleep 30
            fi
            
            if [ $i -eq 10 ]; then
              echo "❌ Health check failed after 10 attempts"
              exit 1
            fi
          done
        working-directory: ./terraform

  notify-slack:
    name: 'Notify Team'
    runs-on: ubuntu-latest
    needs: [terraform-apply-staging, terraform-apply-production]
    if: always() && (needs.terraform-apply-staging.result != 'skipped' || needs.terraform-apply-production.result != 'skipped')
    
    steps:
      - name: Determine Environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi
          
      - name: Notify Slack Success
        if: needs.terraform-apply-staging.result == 'success' || needs.terraform-apply-production.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            🚀 **Breiq Infrastructure Deployment Successful!**
            
            • **Environment**: ${{ steps.env.outputs.environment }}
            • **Branch**: ${{ github.ref_name }}
            • **Commit**: ${{ github.sha }}
            • **Actor**: @${{ github.actor }}
            
            Instagram-level performance infrastructure is now live! 🎬✨
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          
      - name: Notify Slack Failure
        if: needs.terraform-apply-staging.result == 'failure' || needs.terraform-apply-production.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            ❌ **Breiq Infrastructure Deployment Failed!**
            
            • **Environment**: ${{ steps.env.outputs.environment }}
            • **Branch**: ${{ github.ref_name }}
            • **Commit**: ${{ github.sha }}
            • **Actor**: @${{ github.actor }}
            
            Please check the logs and fix the issues.
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}